/** * Copyright 2021 Huawei Technologies Co., Ltd * <p> * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * <p> * http://www.apache.org/licenses/LICENSE-2.0 * <p> * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.mindspore.imagesegmentation;import android.annotation.SuppressLint;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Matrix;import android.graphics.drawable.BitmapDrawable;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.provider.MediaStore;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.ImageView;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import androidx.core.content.FileProvider;import androidx.recyclerview.widget.GridLayoutManager;import androidx.recyclerview.widget.RecyclerView;import com.alibaba.android.arouter.facade.annotation.Route;import com.bumptech.glide.Glide;import com.mindspore.common.base.grid.MSGridSpacingItemDecoration;import com.mindspore.common.config.MSLinkUtils;import com.mindspore.common.utils.Utils;import com.mindspore.customview.dialog.NoticeDialog;import com.mindspore.imagesegmentation.help.BitmapUtils;import com.mindspore.imagesegmentation.help.ModelTrackingResult;import com.mindspore.imagesegmentation.help.TrackingMobile;import java.io.File;import java.io.FileNotFoundException;import java.lang.ref.WeakReference;@Route(path = "/segmentation/SegmentationMainActivity")public class SegmentationMainActivity extends AppCompatActivity implements OnBackgroundImageListener {    private static final String TAG = "SegmentationMainActivity";    private static final int[] IMAGES = {R.drawable.img_002, R.drawable.img_001, R.drawable.img_003, R.drawable.img_004, R.drawable.img_005,            R.drawable.img_006, R.drawable.img_007, R.drawable.icon_default};    private static final int RC_CHOOSE_PHOTO = 1;    private static final int RC_CHOOSE_PHOTO_FOR_BACKGROUND = 11;    private static final int RC_CHOOSE_CAMERA = 2;    private boolean isPreViewShow = false;    private ImageView imgPreview;    private TextView textOriginImage;    private ProgressBar progressBar;    private Uri imageUri;    private Bitmap originBitmap, lastOriginBitmap;    private TrackingMobile trackingMobile;    private int selectedPosition;    private boolean isRunningModel;    private Handler mHandler;    private ModelTrackingResult modelTrackingResult;    private Bitmap processedImage;    private BitmapDrawable customBack;    private NoticeDialog noticeDialog;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.segmentation_activity_main);        init();        trackingMobile = new TrackingMobile(this);    }    private void init() {        imgPreview = findViewById(R.id.img_origin);        textOriginImage = findViewById(R.id.tv_image);        progressBar = findViewById(R.id.progress);        Toolbar mToolbar = findViewById(R.id.segmentation_toolbar);        setSupportActionBar(mToolbar);        mToolbar.setNavigationOnClickListener(view -> finish());        RecyclerView recyclerView = findViewById(R.id.recyclerview);        GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 4);        recyclerView.setLayoutManager(gridLayoutManager);        recyclerView.addItemDecoration(new MSGridSpacingItemDecoration(10));        recyclerView.setAdapter(new StyleRecyclerViewAdapter(this, IMAGES, this));    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.menu_setting_app, menu);        return true;    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        int itemId = item.getItemId();        if (itemId == R.id.item_help) {            showHelpDialog();        } else if (itemId == R.id.item_more) {            Utils.openBrowser(this, MSLinkUtils.HELP_IMAGE_SEGMENTATION);        }        return super.onOptionsItemSelected(item);    }    private void showHelpDialog() {        noticeDialog = new NoticeDialog(this);        noticeDialog.setTitleString(getString(R.string.explain_title));        noticeDialog.setContentString(getString(R.string.explain_image_segmentation));        noticeDialog.setYesOnclickListener(() -> {            noticeDialog.dismiss();        });        noticeDialog.show();    }    public void onClickPhoto(View view) {        openGallay(RC_CHOOSE_PHOTO);        textOriginImage.setVisibility(View.GONE);    }    public void onClickCamera(View view) {        openCamera();        textOriginImage.setVisibility(View.GONE);    }    public void onClickRecovery(View view) {        if (originBitmap != null) {            Glide.with(this).load(originBitmap).into(imgPreview);            isPreViewShow = true;        } else {            Toast.makeText(this, R.string.toast_original, Toast.LENGTH_SHORT).show();            isPreViewShow = false;        }    }    @SuppressLint("LongLogTag")    public void onClickSave(View view) {        if (this.processedImage == null) {            Log.e(TAG, "null processed image");            Toast.makeText(this.getApplicationContext(), R.string.no_pic_neededSave, Toast.LENGTH_SHORT).show();        } else {            BitmapUtils.saveToAlbum(getApplicationContext(), this.processedImage);            Toast.makeText(this.getApplicationContext(), R.string.save_success, Toast.LENGTH_SHORT).show();        }    }    private void openGallay(int request) {        Intent intent = new Intent(Intent.ACTION_PICK, null);        intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, "image/*");        startActivityForResult(intent, request);    }    private void openCamera() {        Intent intentToTakePhoto = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);        String mTempPhotoPath = Environment.getExternalStorageDirectory() + File.separator + "photo.jpeg";        imageUri = FileProvider.getUriForFile(this, getApplicationContext().getPackageName() + ".fileprovider", new File(mTempPhotoPath));        intentToTakePhoto.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);        startActivityForResult(intentToTakePhoto, RC_CHOOSE_CAMERA);    }    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if (resultCode == RESULT_OK) {            if (RC_CHOOSE_PHOTO == requestCode) {                if (null != data && null != data.getData()) {                    this.imageUri = data.getData();                    showOriginImage();                } else {                    finish();                }            } else if (RC_CHOOSE_PHOTO_FOR_BACKGROUND == requestCode) {                if (null != data && null != data.getData()) {                    showCustomBack(data.getData());                } else {                    finish();                }            } else if (RC_CHOOSE_CAMERA == requestCode) {                if (null != data && null != data.getData()) {                    this.imageUri = data.getData();                    showOriginImage();                }                showOriginCamera();            }        } else {            textOriginImage.setVisibility(!isPreViewShow ? View.VISIBLE : View.GONE);        }    }    private void showOriginImage() {        File file = BitmapUtils.getFileFromMediaUri(this, imageUri);        Bitmap photoBmp = BitmapUtils.getBitmapFormUri(this, Uri.fromFile(file));        int degree = BitmapUtils.getBitmapDegree(file.getAbsolutePath());        originBitmap = BitmapUtils.rotateBitmapByDegree(photoBmp, degree).copy(Bitmap.Config.ARGB_8888, true);        if (originBitmap != null) {            Glide.with(this).load(originBitmap).into(imgPreview);            isPreViewShow = true;        } else {            isPreViewShow = false;        }    }    private void showOriginCamera() {        try {            originBitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));        } catch (FileNotFoundException e) {            e.printStackTrace();        }        // Determine how much to scale down the image.        if (originBitmap != null) {            Glide.with(this).load(originBitmap).into(imgPreview);        }    }    private void showCustomBack(Uri imageUri) {        File file = BitmapUtils.getFileFromMediaUri(this, imageUri);        Bitmap photoBmp = BitmapUtils.getBitmapFormUri(this, Uri.fromFile(file));        int degree = BitmapUtils.getBitmapDegree(file.getAbsolutePath());        Bitmap bitmap = BitmapUtils.rotateBitmapByDegree(photoBmp, degree).copy(Bitmap.Config.ARGB_8888, true);        customBack = new BitmapDrawable(getResources(), bitmap);        changeBackground(false);    }    private void startRunningModel(boolean isDemo) {        if (!isRunningModel) {            if (originBitmap == null) {                Toast.makeText(this, R.string.toast_original, Toast.LENGTH_SHORT).show();                return;            }            progressBar.setVisibility(View.VISIBLE);            new Thread(() -> {                isRunningModel = true;                modelTrackingResult = trackingMobile.execute(originBitmap);                if (modelTrackingResult != null) {                    isRunningModel = false;                    lastOriginBitmap = originBitmap;                    isPreViewShow = true;                } else {                    isPreViewShow = false;                }                Looper.prepare();                mHandler = new MyHandler(SegmentationMainActivity.this, isDemo);                mHandler.sendEmptyMessage(1);                Looper.loop();            }).start();        } else {            Toast.makeText(this, R.string.toast_model_run, Toast.LENGTH_SHORT).show();        }    }    private static class MyHandler extends Handler {        private final WeakReference<SegmentationMainActivity> weakReference;        private final boolean isDemo;        public MyHandler(SegmentationMainActivity activity, boolean demo) {            weakReference = new WeakReference<>(activity);            this.isDemo = demo;        }        @Override        public void handleMessage(Message msg) {            super.handleMessage(msg);            SegmentationMainActivity activity = weakReference.get();            if (msg.what == 1) {                if (null != activity && null != activity.modelTrackingResult) {                    activity.changeBackground(isDemo);                }            }        }    }    public void changeBackground(boolean isDemo) {        runOnUiThread(() -> {            if (null != modelTrackingResult && null != modelTrackingResult.getBitmapMaskOnly()) {                if (progressBar.getVisibility() == View.VISIBLE) {                    progressBar.setVisibility(View.INVISIBLE);                }                Bitmap foreground = modelTrackingResult.getBitmapMaskOnly();                Matrix matrix = new Matrix();                matrix.setScale(0.7f, 0.7f);                foreground = Bitmap.createBitmap(foreground, 0, 0, foreground.getWidth(), foreground.getHeight(), matrix, false);                SegmentationMainActivity.this.imgPreview.setDrawingCacheEnabled(true);                SegmentationMainActivity.this.imgPreview.setBackground(isDemo ? getDrawable(IMAGES[selectedPosition]) : customBack);                SegmentationMainActivity.this.imgPreview.setImageBitmap(foreground);                SegmentationMainActivity.this.processedImage = Bitmap.createBitmap(SegmentationMainActivity.this.imgPreview.getDrawingCache());                SegmentationMainActivity.this.imgPreview.setDrawingCacheEnabled(false);            } else {                Toast.makeText(this, R.string.toast_original, Toast.LENGTH_SHORT).show();            }        });    }    @Override    public void onBackImageSelected(int position) {        selectedPosition = position;        if (lastOriginBitmap == originBitmap) {            changeBackground(true);        } else {            startRunningModel(true);        }    }    @Override    public void onImageAdd(View view) {        if (originBitmap == null) {            Toast.makeText(this, R.string.toast_original, Toast.LENGTH_SHORT).show();            return;        }        if (lastOriginBitmap == originBitmap) {            openGallay(RC_CHOOSE_PHOTO_FOR_BACKGROUND);        } else {            startRunningModel(false);        }    }    @Override    protected void onDestroy() {        super.onDestroy();        trackingMobile.free();        if (mHandler != null) {            mHandler.removeCallbacksAndMessages(null);        }        BitmapUtils.recycleBitmap(this.originBitmap, this.lastOriginBitmap, this.processedImage);    }}